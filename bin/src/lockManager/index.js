"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const parsedDepedencies_1 = __importDefault(require("../parsedDepedencies"));
class lockManager {
    save(lock, data) {
        //fs.writeFileSync(lock, this.generate(data));
    }
    parse(data) {
        var text = data
            .replace(/[# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# bunc lockfile v1]{84}/g, "")
            .replace(/[\t]/g, "")
            .replace(/[version]{7}/, '"version"')
            .replace(/[resolved]{8}/, '"resolved"')
            .replace(/[integrity]{9}/, '"integrity"')
            .replace(/[dependencies]{12}/, '"dependencies"')
            .replace(/[ ]/g, ":")
            .replaceAll("::", ":");
        text = `{${text}`;
        if (text.indexOf("integrity") != -1) {
            const integrityStart = text.indexOf("integrity") - 1 + 15;
            var lineCount = 0;
            var integrityEnd = 0;
            var sumLength = 0;
            var newText = "";
            for (let line of text.split("\n")) {
                if (line.indexOf("integrity") != -1) {
                    integrityEnd = sumLength + (line.length - 1) + 10;
                }
                else {
                    sumLength += line.length - 1;
                }
                if (lineCount == 0) {
                    newText += line + ":{";
                }
                else if (lineCount == text.split("\n").length - 1) {
                    newText += line + "}}";
                }
                else {
                    newText += line + ",\n";
                }
                lineCount += 1;
            }
            text = newText
                .replaceAll("[,", "[")
                .replaceAll("},", "}")
                .replaceAll("{,", "{")
                .replaceAll(",\n}", "\n}");
            const stringRegex = `${text.substring(integrityStart, integrityEnd)}`;
            const regexToRun = new RegExp(stringRegex, "gi");
            text = text.replace(regexToRun, `"${text.substring(integrityStart, integrityEnd)}"`);
        }
        console.log(text);
        return JSON.parse(text);
    }
    get(currentWorkingDirectory) {
        const resolvedLockPath = path_1.default.resolve(currentWorkingDirectory, "bunc.lock");
        if (fs_extra_1.default.existsSync(resolvedLockPath)) {
            return this.parse(fs_extra_1.default.readFileSync(resolvedLockPath, "utf8").toString());
        }
        return this.parse(this.generate([]));
    }
    generate(packages) {
        var packageLock = "# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# bunc lockfile v1";
        for (let packageData of packages) {
            console.log(packageData);
            const { name, version, resolved, integrity, dependencies } = packageData;
            packageLock += `"${name}@^${version}"\n`;
            packageLock += `\tversion "${version}"\n`;
            if (resolved) {
                packageLock += `\tresolved "${resolved}"\n`;
            }
            if (integrity) {
                packageLock += `\tintegrity "${integrity}"\n`;
            }
            if (dependencies) {
                const parsedData = (0, parsedDepedencies_1.default)(JSON.stringify(packageData));
                packageLock += `\tdependencies: ${parsedData}`;
            }
        }
        return packageLock;
    }
}
exports.default = lockManager;
